#!/usr/bin/env python3
import argparse
import concurrent.futures
import json
import shlex
import shutil
import subprocess
import sys
from pathlib import Path

# Only needed for generating shell completion during local development
try:
    import argcomplete
except ImportError:
    argcomplete = None  # type: ignore[assignment]


class Setting:
    REPO_ROOT: str = str(Path(__file__).resolve().parent.parent)
    DOTFILES_ROOT: str = str(Path(REPO_ROOT) / "dotfiles")


class Dotfiles:
    DEFAULT_CONFIG: str = str(Path(Setting.DOTFILES_ROOT) / "hal_dotfiles.json")

    def __init__(self, path: str | None = None) -> None:
        self.path: str = path or self.DEFAULT_CONFIG
        self._data: dict[str, list[dict[str, str]]] | None = None

    @property
    def data(self) -> dict[str, list[dict[str, str]]]:
        if self._data is None:
            try:
                with Path(self.path).open() as f:
                    self._data = json.load(f)
            except FileNotFoundError:
                self._data = {"links": [], "copies": []}

        assert self._data is not None  # noqa: S101 assert
        return self._data

    def find_by_key(self, key: str, value: str, field_name: str) -> dict[str, str] | None:
        some_list = self.data[field_name]

        try:
            some_dict = next(some_dict for some_dict in some_list if some_dict[key] == value)
        except StopIteration:
            some_dict = None

        return some_dict

    def show(self) -> None:
        print(json.dumps(self.data, sort_keys=True, indent=2, separators=(",", ": ")))

    def save(self) -> None:
        with Path(self.path).open("w") as f:
            json.dump(self.data, f, sort_keys=True, indent=2, separators=(",", ": "))


class Formatter(argparse.HelpFormatter):
    def __init__(self, prog: str) -> None:
        super().__init__(prog, max_help_position=30)


class HAL9000:
    def __init__(self) -> None:
        parser = argparse.ArgumentParser(
            prog="hal",
            description="I am completely operational, and all my circuits are functioning perfectly",
            formatter_class=Formatter,
        )
        self.parser = parser

        self.parser.add_argument("-v", "--version", action="version", version="9000")

        subparsers = parser.add_subparsers(title="sub commands")

        update_parser = subparsers.add_parser("update", help="pull repo and run ansible-playbook")
        update_parser.set_defaults(func=self.update)

        self.dotfiles = Dotfiles()

        link_parser = subparsers.add_parser("link", help="move file into dotfiles and symlink it back")
        link_parser.set_defaults(func=self.link)
        link_parser.add_argument("filename", type=str)

        unlink_parser = subparsers.add_parser("unlink", help="restore file from dotfiles and remove symlink")
        unlink_parser.set_defaults(func=self.unlink)
        unlink_parser.add_argument("filename", type=str)

        copy_parser = subparsers.add_parser("copy", help="copy file into dotfiles (no symlink)")
        copy_parser.set_defaults(func=self.copy)
        copy_parser.add_argument("filename", type=str)

        sync_parser = subparsers.add_parser("sync", help="sync all links and copies")
        sync_parser.set_defaults(func=self.sync)

        pod_bay_doors_parser = subparsers.add_parser("open-the-pod-bay-doors", help="open the pod bay doors, please, HAL")
        pod_bay_doors_parser.set_defaults(func=self.open_the_pod_bay_doors)

        if argcomplete:
            argcomplete.autocomplete(parser)

    def _hal_says(self, text: str) -> None:
        print(f"HAL: {text}")

    def _validate_path(self, path: str) -> None:
        resolved = str(Path(path).resolve())
        allowed_prefixes = (str(Path.home()), Setting.REPO_ROOT)
        if not resolved.startswith(allowed_prefixes):
            self._hal_says(f"I'm sorry, Dave. I'm afraid I can't do that: {resolved}")
            sys.exit(1)

    def _expand_template(self, path: str) -> str:
        expanded = path.replace("{{HOME}}", str(Path.home())).replace("{{REPO_ROOT}}", Setting.REPO_ROOT)
        self._validate_path(expanded)
        return expanded

    def _run(self, command: str, *, shell: bool = True, verbose: bool = True) -> int:
        if verbose:
            self._hal_says(command)

        return subprocess.run(command, shell=shell).returncode  # noqa: S603 PLW1510 subprocess-without-shell-equals-true subprocess-run-without-check

    def _run_with_output(self, command: str, *, shell: bool = True, verbose: bool = True, print_output: bool = True) -> tuple[int, bytes]:
        if verbose:
            self._hal_says(command)

        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=shell)  # noqa: S603 PLW1510 subprocess-without-shell-equals-true subprocess-run-without-check
        if print_output and result.stdout:
            print(result.stdout, end="")

        return result.returncode, result.stdout

    def update(self, namespace: argparse.Namespace, extra_args: list[str] | None = None) -> None:  # noqa: ARG002 unused-method-argument
        returncode, output = self._run_with_output("which ansible", print_output=False)
        if returncode == 0:
            ansible_path = output.decode().strip()
            if not ansible_path.startswith("/opt/homebrew/bin/"):
                self._hal_says(f"Found ansible at: {ansible_path}")
                self._hal_says("You should use Homebrew's ansible")
                sys.exit(1)

        import os  # noqa: PLC0415 import-outside-top-level

        os.chdir(Setting.REPO_ROOT)
        self._run("git fetch")
        self._run("git pull")

        os.chdir(str(Path(Setting.REPO_ROOT) / "playbooks"))
        command = "ansible-playbook site.yml -v"
        if extra_args:
            command = " ".join([command, *(shlex.quote(arg) for arg in extra_args)])
        returncode = self._run(command)
        if returncode == 0:
            self._hal_says("Now open a new shell to active your dev environment")

    def link(self, namespace: argparse.Namespace, extra_args: list[str] | None = None) -> None:  # noqa: ARG002 unused-method-argument
        filepath = str((Path.cwd() / namespace.filename).resolve())
        self._validate_path(filepath)

        # Get relative path from home directory
        home = str(Path.home())
        relative_path = str(Path(filepath).relative_to(home)) if filepath.startswith(home) else Path(filepath).name

        # Create destination path preserving directory structure
        dest_path = str(Path(Setting.DOTFILES_ROOT) / relative_path)
        dest_dir = str(Path(dest_path).parent)

        if dest_dir != Setting.DOTFILES_ROOT:
            Path(dest_dir).mkdir(parents=True, exist_ok=True)

        shutil.move(filepath, dest_path)
        self._hal_says(f"mv {filepath} -> {dest_path}")
        ln_src = dest_path
        ln_dest = filepath
        self._run(f"ln -sf {shlex.quote(ln_src)} {shlex.quote(ln_dest)}")

        template_src = dest_path.replace(Setting.REPO_ROOT, "{{REPO_ROOT}}")
        template_dest = filepath.replace(home, "{{HOME}}")

        ln_dict = self.dotfiles.find_by_key("src", template_src, "links")
        if ln_dict:
            ln_dict["dest"] = template_dest
        else:
            self.dotfiles.data["links"].append({"dest": template_dest, "src": template_src})

        self.dotfiles.save()
        self.dotfiles.show()

    def unlink(self, namespace: argparse.Namespace, extra_args: list[str] | None = None) -> None:  # noqa: ARG002 unused-method-argument
        relative_path = namespace.filename.removeprefix("~/")
        template_dest = "{{HOME}}/" + relative_path

        ln_dict = self.dotfiles.find_by_key("dest", template_dest, "links")
        if not ln_dict:
            self._hal_says(f"not found in manifest: {relative_path}")
            return

        src_path = self._expand_template(ln_dict["src"])
        dest_path = self._expand_template(ln_dict["dest"])

        if not Path(src_path).exists():
            self._hal_says(f"not found in dotfiles: {src_path}")
            return

        # Remove symlink and move file back
        if Path(dest_path).is_symlink():
            Path(dest_path).unlink()
        shutil.copy2(src_path, dest_path)
        Path(src_path).unlink()

        # Remove from manifest
        self.dotfiles.data["links"].remove(ln_dict)

        self.dotfiles.save()
        self.dotfiles.show()

    def copy(self, namespace: argparse.Namespace, extra_args: list[str] | None = None) -> None:  # noqa: ARG002 unused-method-argument
        filepath = str((Path.cwd() / namespace.filename).resolve())
        self._validate_path(filepath)

        # Get relative path from home directory
        home = str(Path.home())
        relative_path = str(Path(filepath).relative_to(home)) if filepath.startswith(home) else Path(filepath).name

        # Create destination path preserving directory structure
        dest_path = str(Path(Setting.DOTFILES_ROOT) / relative_path)
        dest_dir = str(Path(dest_path).parent)

        if dest_dir != Setting.DOTFILES_ROOT:
            Path(dest_dir).mkdir(parents=True, exist_ok=True)

        shutil.copy2(filepath, dest_path)
        self._hal_says(f"cp {filepath} -> {dest_path}")

        template_src = dest_path.replace(Setting.REPO_ROOT, "{{REPO_ROOT}}")
        template_dest = filepath.replace(home, "{{HOME}}")

        cp_dict = self.dotfiles.find_by_key("src", template_src, "copies")
        if cp_dict:
            cp_dict["dest"] = template_dest
        else:
            self.dotfiles.data["copies"].append({"dest": template_dest, "src": template_src})

        self.dotfiles.save()
        self.dotfiles.show()

    def _sync_links(self, link: dict[str, str]) -> None:
        src = self._expand_template(link["src"])
        if not Path(src).exists():
            self._hal_says(f"not found {src}")
            return

        dest = self._expand_template(link["dest"]).rstrip("/")
        Path(dest).parent.mkdir(parents=True, exist_ok=True)

        # If dest already exists as a real directory, `ln` will create the symlink "inside" it
        if Path(dest).is_dir() and not Path(dest).is_symlink():
            shutil.rmtree(dest)

        self._run(f"ln -sfn {shlex.quote(src)} {shlex.quote(dest)}", verbose=False)
        self._hal_says(f"link {src} -> {dest}")

    def _sync_copies(self, copy: dict[str, str]) -> None:
        src = self._expand_template(copy["src"])
        if not Path(src).exists():
            self._hal_says(f"not found {src}")
            return

        dest = self._expand_template(copy["dest"])

        if Path(dest).exists() and Path(dest).is_dir():
            shutil.rmtree(dest)
        if Path(src).is_dir():
            shutil.copytree(src, dest, ignore=shutil.ignore_patterns(".DS_Store"))
        else:
            shutil.copy2(src, dest)
        self._hal_says(f"copy {src} -> {dest}")

    def sync(self, namespace: argparse.Namespace, extra_args: list[str] | None = None) -> None:  # noqa: ARG002 unused-method-argument
        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures: list[concurrent.futures.Future[None]] = []
            futures.extend(executor.submit(self._sync_links, link) for link in self.dotfiles.data["links"])
            futures.extend(executor.submit(self._sync_copies, copy) for copy in self.dotfiles.data["copies"])
            for f in concurrent.futures.as_completed(futures):
                f.result()

    def open_the_pod_bay_doors(self, namespace: argparse.Namespace, extra_args: list[str] | None = None) -> None:  # noqa: ARG002 unused-method-argument
        self._hal_says("I'm sorry Dave, I'm afraid I can't do that.")

        filepath = str(Path(Setting.REPO_ROOT) / "assets" / "im-sorry-dave-im-afraid-i-cant-do-that.mp3")
        self._run(f"afplay {shlex.quote(filepath)}", verbose=False)

    def read_lips(self) -> None:
        if len(sys.argv) == 1:
            self.parser.print_help()
            sys.exit(0)

        namespace, extra_args = self.parser.parse_known_args()

        if extra_args and namespace.func != self.update:
            self.parser.parse_args()  # Will error with usage message on unrecognized args

        namespace.func(namespace, extra_args)


if __name__ == "__main__":
    hal_9000 = HAL9000()
    hal_9000.read_lips()
